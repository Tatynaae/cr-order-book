# Crypto Order Book — Архитектура

## Цели

* Отображать обновления Binance depth без перерендера UI на каждое сообщение WebSocket (100+ msg/sec).
* Жёстко разделить слой получения/обработки данных и слой рендеринга.
* Обязательно прогонять входящие данные через legacy-декодер `BinaryDecoder`.

## Поток данных (разделение слоёв)

UI **никогда** не читает WebSocket напрямую.

* `OrderBookStore`:

  * подключается к WebSocket (Binance) или `MockSocket`
  * парсит raw-сообщение → JSON → `BinaryDecoder.decode(raw)`
  * буферизует декодированные апдейты в `pending[]`
  * применяет апдейты к “сырым” структурам стакана в памяти (`Map`)
  * предоставляет UI стабильный снимок через `getSnapshot()`
* UI:

  * подписывается на стор через `useSyncExternalStore`
  * перерисовывается только когда стор делает `notify()` (не чаще 10 раз/сек)

## Троттлинг / буферизация

Почему нельзя обновлять UI на каждое сообщение:

* поток depth может приходить 100–200 msg/sec
* если делать setState на каждое сообщение, React начнёт тратить слишком много времени на reconciliation → интерфейс “дёргается”/зависает

Реализация:

* на каждое сообщение: `pending.push(decodedUpdate)`
* отдельный цикл: `setInterval(flush, 100ms)` → максимум 10 обновлений DOM в секунду
* `flush()`:

  * применяет все накопленные апдейты
  * очищает очередь
  * один раз строит snapshot
  * один раз уведомляет подписчиков

Гарантии:

* UI обновляется **≤ 10 раз/сек**
* слой получения данных работает на полной скорости и не блокирует рендер

## BinaryDecoder (legacy-интеграция)

Хотя Binance присылает JSON, каждое сообщение **всё равно** проходит через:

* `decoded = decoder.decode(parsedJson)`

Это принудительно реализовано внутри `OrderBookStore.onmessage`.

## Группировка по Tick Size

“Сырой” стакан хранится как:

* `Map<price, amount>` отдельно для bids/asks

При сборке snapshot:

* группируем цены по шагу `tickSize`:

  * **bids**: `floor(price / tickSize) * tickSize` (вниз)
  * **asks**: `ceil(price / tickSize) * tickSize` (вверх)
* суммируем объёмы внутри одной “корзины” (bucket)
* сортируем:

  * bids по убыванию цены
  * asks по возрастанию цены

Выбор top N уровней (например, 25).

Логика группировки находится в src/lib/groupLevels.ts и покрыта юнит-тестом.

Drift Detection (пропуск пакетов по sequence)

BinaryDecoder возвращает поле
